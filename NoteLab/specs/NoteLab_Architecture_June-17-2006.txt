
Tools
------
Each of these classes are defined because each tool has its own 
cursor image, name, and hotspot.  Also, most tools actually 
draw something on the canvas.

public interface Tool extends ObjectStateAccessible, CopyReady<Tool>
{
   public void drawLine(Graphics2D g2d, MPoint endPoint, 
                        MAffineTransform transform);
   
   public Image getToolImage();
   public Point getToolHotSpot();
   public String getToolName();
}

public class Pen implements Tool
{
   private int width;
   private Color color;
   private BufferedImage penImage;

   public Pen()
   public Pen(int width, Color color)
   
   public Color getColor()
   public void setColor(Color color)

   public float getWidth()
   public void setWidth(int width)

   public void drawLine(Graphics2D g2d, MPoint endPoint, 
                        MAffineTransform transform);

   public Image getToolImage()
   public Point getToolHotSpot()
   public String getToolName()

   public ObjectState getDefaultObjectState()
   public ObjectState getObjectState()
   public void setObjectState(ObjectState state)

   public Pen getCopy()

   private void drawPenImage()
   private static void fillObjectState(ObjectState state, 
                                       float width, Color color)
   private BasicStroke constructJavaStroke()
}


public class Selecter implements Tool<Selecter>
{
   public Selecter()

   // draws a dotted line which is used to specify a 
   // selected region
   public void drawLine(Graphics2D g2d, MPoint endPoint, 
                        MAffineTransform transform);

   public Image getToolImage()
   public Point getToolHotSpot()
   public String getToolName()

   public ObjectState getDefaultObjectState()
   public ObjectState getObjectState()
   public void setObjectState(ObjectState state)

   public Selecter getCopy()
}

public class Deleter implements Tool<Deleter>
{
   public Deleter()

   // does nothing
   public void drawLine(Graphics2D g2d, MPoint endPoint, 
                        MAffineTransform transform);

   public Image getToolImage()
   public Point getToolHotSpot()
   public String getToolName()

   public ObjectState getDefaultObjectState()
   public ObjectState getObjectState()
   public void setObjectState(ObjectState state)

   public Deleter getCopy()
}

// used by both selection paths and strokes
public class Path
{
   private LinkedList<MLine> lineList;
   private MPoint curPoint;
   
   public Path(MPoint initialPoint)
   
   public void addPoint(MPoint point)
   public void finishStroke()
}


public class Stroke implements Printable, SVGExportable, Renderable, 
                               CopyReady<Stroke>
{
   private Tool tool;
   private Path path;
   
   public Stroke(Tool tool, MPoint initPoint)
   
   public Tool getTool()
   public void setTool(Tool tool)
   
   public Path getPath();
   
   public int print(Graphics graphics, 
                    PageFormat pageFormat, 
                    int pageIndex)
                        throws PrinterException
                        
   public void appendSVGCode(StringBuffer buffer)

   public void renderInto(Graphics2D g2d, MAffineTransform transform)
   
   public Stroke getCopy()
   
   private void setCurrentPoint(MPoint point)
}


public class Page implements Renderable, SVGExportable, Printable, 
                             CopyReady<Page>, ObjectStateAccessible
{
   private MDimension dimension;
   private LinkedList<Stroke> strokeList;
   private Paper paper;
   
   public Page()
   public Page(MDimension dim)
   public Page(MDimension dim, PaperType paper)
   
   public void addStroke(Stroke stroke)
   
   public void renderInto(Graphics2D g2d, MAffineTransform transform)
   public void appendSVGCode(StringBuffer buffer)
   public int print(Graphics graphics, PageFormat pageFormat, int pageIndex)
         throws PrinterException
   
   public Paper getPaper()
   public void setPaper(PaperType paper)
   
   public MDimension getDimension()
   public void setDimension(MDimension dimension)
   
   public MValue getLength()
   public void setLength(MValue length)
   
   public MValue getWidth()
   public void setWidth(MValue width)
   
   public Page getCopy()
   
   @Override
   public String toString()

   public ObjectState getDefaultObjectState()
   public ObjectState getObjectState()
   public void setObjectState(ObjectState state)
}


public class Paper implements Renderable, CopyReady<Paper>
{
   private static int GRID_WIDTH = (int)(new MValue(1, Unit.CM)).
                                            getValue(Unit.PIXEL);
   private static int COLLEGE_WIDTH = (int)(new MValue(1.1, Unit.CM)).
                                            getValue(Unit.PIXEL);
   private static int WIDE_WIDTH = (int)(1.5*COLLEGE_WIDTH);
   
   public enum PaperType
   {
      Plain, 
      Graph, 
      CollegeRuled, 
      WideRuled
   };
   
   private MDimension dimension;
   private PaperType type;
   
   public Paper(PaperType paperType, MDimension dimension)
   
   public MDimension getDimension()
   public void setDimension(MDimension dimension)
   
   public MValue getLength()
   public void setLength(MValue length)
   
   public MValue getWidth()
   public void setWidth(MValue width)
   
   public PaperType getPaperType()
   public void setPaperType(PaperType type)
   
   public Paper getCopy()
   
   private int getPixelWidth(MAffineTransform transform)
   private int getPixelHeight(MAffineTransform transform)
   
   public void renderInto(Graphics2D g2d, MAffineTransform transform)
   private void renderLinedPage(Graphics2D g2d, int lineWidth, 
                                MAffineTransform transform)
   private int transformPixelLength(int length, MAffineTransform transform)
   private void renderLinesDown(Graphics2D g2d, int gap, 
                                int leftMargin, int rightMargin, 
                                int topMargin, int bottomMargin, 
                                MAffineTransform transform)
   private void renderLinesAcross(Graphics2D g2d, int gap, 
                                  int leftMargin, int rightMargin, 
                                  int topMargin, int bottomMargin, 
                                  MAffineTransform transform)
}


public class Binder implements Printable, SVGExportable, Renderable
{
   private LinkedList<LocatedPage> pageList;
   private int curPage;
   private Stroke curStroke;
   
   private int numColumns;
   
   public Binder(Page ... pages)
   
   public void addNewPage()
   public void addPage(Page page)
   
   public int getNumColumns()
   public void setNumColumns(int num)
   
   public void next()
   public void previous()
   public void setCurrentPage(MPoint point)
   
   private void updateArrangement()
   
   public boolean isInCurrentPage(MPoint point)
   public int getPageIndexAtPoint(MPoint point)
   private MPoint getPointRelativeToCurrentPage(MPoint point)
   
   public boolean isStrokeStarted()
   public void startStroke(Tool tool, MPoint initialPoint)
   public void addPointToStroke(MPoint point)
   public void finishStroke()
   
   public MPoint getClippedPoint(MPoint globalPoint)
   
   public int print(Graphics graphics, PageFormat pageFormat, int pageIndex)
         throws PrinterException
   public void appendSVGCode(StringBuffer buffer)
   public void renderInto(Graphics2D g2d, MAffineTransform transform)
   
   public MValue getWidth(Unit unit)
   public MValue getLength(Unit unit)
   
   private LocatedPage getCurrentLocatedPage()
   public Page getCurrentPage()
   public int getCurrentPageIndex()
   public void setCurrentPageIndex(int index)
   
   public void copyPage()
   
   private class LocatedPage
   {
      public Page page;
      public MPoint location;
      
      public LocatedPage(Page page)
      public LocatedPage(Page page, MPoint location)
   }
}


public interface SubCanvas<T extends Tool>
{
   public void pathSelected(Path path);
   public void pointSelected(MPoint point);
   
   public T getTool();
}


// this class is still in MPoint space
// this class listens to MouseEvents and invokes the corresponding methods 
// of the SubCanvases.  That way, they don't have to worry about the mouse.
public class CompositeCanvas implements MouseMotionListener, MouseListener
{
   public enum CanvasTool
   {
      pen, 
      pointSelecter, 
      regionSelecter, 
      deleter;
      
      private CanvasTool(Tool tool);
      
      public Tool getTool();
   };

   private PrintCanvas printCanvas;
   private RegionSelectionCanvas regSelCanvas;
   private PointSelectionCanvas  ptSelCanvas;
   private DeletionCanvas delCanvas;
   
   public PrintCanvas()
   {
      
   }
   
   // these methods make sure all of the SubCanvases have 
   // the same dimensions
   public MDimension getSize();
   public void setSize(MDimension size);
   
   public MValue getWidth();
   public void setWidth(MValue val);
   
   public MValue getHeight();
   public void setHeight(MValue val);
   
   public Tool get
   
   // invoke pointSelected() 
   // and add the point to the path
   public void mouseDragged(MouseEvent e)
   public void mouseMoved(MouseEvent e)
   
   public void mouseClicked(MouseEvent e)
   // initialize a Path
   public void mousePressed(MouseEvent e)
   // invoke pathSelected()
   public void mouseReleased(MouseEvent e)
   
   public void mouseEntered(MouseEvent e)
   public void mouseExited(MouseEvent e)
}


public class PrintCanvas implements SubCanvas<Pen>
{
   
   
   public void pathSelected(Path path);
   public void pointSelected(MPoint point);
   
   public Pen getTool();
}


